---
title: "Flexdashboard for Multiple Analyses for Iris Data Set"
output: 
  flexdashboard::flex_dashboard:
    theme: united
    # available themes include: default, cerulean, journal, flatly, darkly, 
    #                           readable, spacelab, united, cosmo, lumen, 
    #                           paper, sandstone, simplex, yeti.
    orientation: columns
    vertical_layout: fill
runtime: shiny
---


<style type="text/css">
/* Get a fancy font from Google Fonts */
@import url('https://fonts.googleapis.com/css2?family=Yusei+Magic&display=swap');

body {
  background-color: lightgray;
  color: darkgreen; /* text color */
  text-align: left;
}

.navbar {
	position: fixed;
	display: flex;
	justify-content: center;
	width: 100%;
}

/* Make text visible on inputs */
.shiny-input-container {
  color: purple;
}
<!--
.navbg {
  background-color: blue;
  color: white;
}
-->
</style>                    

\




```{r setup, include=FALSE}
if (!require("flexdashboard")) {
   install.packages("flexdashboard")
   library(flexdashboard)
}
if (!require("shiny")) {
   install.packages("shiny")
   library(shiny)
}
if (!require("plotly")) {
   install.packages("plotly")
   library(plotly)
}
if (!require("ggplot2")) {
   install.packages("ggplot2")
   library(ggplot2)
}
if (!require("tidyverse")) {
   install.packages("tidyverse")
   library(tidyverse)
}
if (!require("stats")) {
   install.packages("stats")
   library(stats)
}
if (!require("fANCOVA")) {
   install.packages("fANCOVA")
   library(fANCOVA)
}

```


```{r data}
## loading data set
## one could also allow use to upload a data file to work with.
iris1 = read.table("https://raw.githubusercontent.com/pengdsci/sta553/main/shiny/iris0.txt", header = TRUE)[,-1]
y.names = names(iris1)
x.names = names(iris1)
spec = unique(iris1$Species)
```


<!--
This siderbar is a common navigation panel.
It provides filters and other user input information for all analyses
-->


Sidebar {.sidebar data-width=200}
==================================


```{r}
radioButtons(inputId = "species",
            label = strong("Species"), 
            choices = c("all", as.vector(spec)), 
            selected = "all")
```

<hr>

<!-- put all input widgets in the same R code chunk.
     The code is the same as we used in the regular R shiny apps-->
```{r}
selectInput(inputId="Y", 
            label = strong("Response Variable: Y"), 
            choices = y.names[-5], 
            selected = y.names[1])

selectInput(inputId="X", 
            label = strong("Predictor Variable: X"), 
            choices = x.names[-5], 
            selected = x.names[2])
      ###
sliderInput("newX", strong("New Value for Prediction:"), 2.5, min = 0, max = 20, step = 0.1)

```


\

<hr>
<!-- We the plain HTML tags to include images or other contents -->
<!--center><img src="https://github.com/pengdsci/sta553/blob/main/image/goldenRamLogo.png?raw=true" width="80" height="80"></center-->
<p style="font-family:Courier; color:Red; font-size: 20px;"><center>
                 <font size =2> <a href="mailto:cpeng@wcupa.edu">
                 <font color="purple">Report bugs to C. Peng </font></a> </font></center></p>




<!-- END of left navigation panel -->

<!-- Although no explicit server function was use this this flexdashboard, 
     we still need to define a dynamic data set
     based on the user's input input information.
-->

```{r}
  workDat = function(){
      if (input$species == "setosa") {
          workingData = iris1[which(iris1$Species == "setosa"),]
      } else if (input$species == "versicolor") {
          workingData = iris1[which(iris1$Species == "versicolor"),]
      } else if (input$species == "virginica") {
          workingData = iris1[which(iris1$Species == "virginica"),]
      } else {
          workingData = iris1
      }
   workingData 
  }
```



Parametric Analyses
=====================================  
    
Column {data-width=450  .tabset .tabset-pills}
-------------------------------------
    


### **plotly Scatterplot** 

<!--
This is the first tab in the tabset. The same shiny graphica function rederPlotly({code for plot....}) needs to be used
as we did in writing graphical functions inside the server function in the standard R shiny apps..
-->

```{r}
renderPlotly({
# hist(workDat()[[input$X]]) 
plot_ly(data = workDat(),
        x =  ~workDat()[[input$X]], 
        y =  ~workDat()[[input$Y]], 
        color = ~workDat()$Species, 
        hovertemplate = paste('<i><b>',input$Y,'<b></i>: %{y}',
                             '<br><b>',input$X,'</b>:  %{x}',
                             '<br><b>',input$species,'</b>'),
        alpha  = 0.9,
        size = ~workDat()[[input$Y]],
        type = "scatter",
        mode = "markers")   %>%
    layout(#title = paste( input$X, "vs", input$Y), 
           plot_bgcolor = "#e5ecf6",
           margin = list(l = 20, r = 20, b = 80, t = 10),
           xaxis = list(title = paste(input$X,'(cm)')), 
           yaxis = list(title = paste(input$Y,'(cm)')), 
           legend = list(title=list(text='<b> Species </b>'),
                         orientation = "h",   # show entries horizontally
                         xanchor = "center",  # use center of legend as anchor
                         x = 0.5)             # put legend in center of x-axis
        )
  })
```



### **Regression** 

<!--
This is the second tab in the tabset. The same rederPlot({code for plot....})
-->


```{r}
renderPlot({
  regdata = workDat()
  if (input$species == "all"){
    m0 = lm(iris1[[input$Y]]~iris1[[input$X]])
    plot(iris1[[input$X]], iris1[[input$Y]],
      main = "",
      type = "p",
      pch = 19,
      col = "blue",
      xlab = input$X,
      ylab = input$Y
      )
    abline(m0, lwd = 2, col = "red")
  } else {
    m1 = lm(workDat()[[input$Y]]~workDat()[[input$X]])
    plot(workDat()[[input$X]], workDat()[[input$Y]],
      main = "",
      type = "p",
      pch = 19,
      col = "blue",
      xlab = input$X,
      ylab = input$Y
      )
    abline(m1, lwd = 2, col = "red")    
  }
})
```



### **Residual Plots**

```{r}
renderPlot({
  regdata = workDat()
  if (input$species == "all"){
    LM = lm(iris1[[input$Y]]~iris1[[input$X]])
  } else {
    LM = lm(workDat()[[input$Y]]~workDat()[[input$X]])
  }
  par(mfrow = c(2,2))
  plot(LM)
})

##

```

### **Prediction**

```{r}
renderPlot({
    dataset = workDat()   # define the working data set

    ###
    m3 = lm(dataset[,input$Y] ~ dataset[,input$X])

    pred.y = coef(m3)[1] + coef(m3)[2]*input$newX
         #####
    plot(dataset[,input$X], dataset[,input$Y], 
    #    xlab = input$X,
         ylab = input$Y,
         main = ""
         #main = paste("Relationship between", input$Y, "and", input$X)
       )
        ## adding a regression line to the plot
     abline(m3,
            col = "red",
            lwd = 1,
            lty=2)
    points(input$newX, pred.y, pch = 19, col = "red", cex = 2)
  })
```


   
   
Column {data-width=350}
-------------------------------------
   


### **ggplot**-Boxplot


```{r fig.align='center', fig.width=4, fig.height=3}
renderPlot({
 #plot(workDat()[[input$X]], workDat()[[input$Y]]) 
 ggplot(data=workDat(), aes(x=workDat()$Species, y=workDat()[[input$X]])) +
        geom_boxplot(aes(fill=workDat()$Species)) +  
        ylab(input$X) + 
        xlab("Species") + 
        #ggtitle(paste("Boxplot of the response variable: ", input$X )) +
        labs(fill = "Species") +
        stat_summary(fun=mean, geom="point", shape=5, size=4)  
})
```


<br>


### **plotly Overlaid Plot** - Distribution of response: Y


```{r fig.align='center', fig.width=4, fig.height=3}
renderPlotly({
  if(input$species == "all"){
    sepal.len.setosa <- iris1[which(iris1$Species == "setosa"),]
    setosa <- density(sepal.len.setosa$Sepal.Length)
    sepal.len.versicolor <- iris1[which(iris1$Species == "versicolor"),]
    versicolor <- density(sepal.len.versicolor$Sepal.Length)
    sepal.len.virginica <- iris1[which(iris1$Species == "virginica"),]
    virginica <- density(sepal.len.virginica$Sepal.Length)
    # plot density curves
    plot_ly(x = ~virginica$x, y = ~virginica$y, 
               type = 'scatter', 
               mode = 'lines', 
               name = 'virginica', 
               fill = 'tozeroy')  %>% 
           # adding more density curves
       add_trace(x = ~versicolor$x, 
                 y = ~versicolor$y, 
                 name = 'versicolor', 
                 fill = 'tozeroy')  %>% 
       add_trace(x = ~setosa$x, 
                 y = ~setosa$y, 
                 name = 'setosa', 
                 fill = 'tozeroy')  %>%   
       layout(xaxis = list(title = paste(input$Y)),
              yaxis = list(title = 'Density'))
    } else {
      den <- density(workDat()[[input$Y]])
     plot_ly(x = ~den$x, 
             y = ~den$y, 
          color = ~input$species, 
          type = 'scatter', 
          mode = 'lines', 
          name = input$species, 
          fill = 'tozeroy')    %>%
      layout(xaxis = list(title = paste(input$Y)),
             yaxis = list(title = 'Density'))
    }
  
  
})
```

<br>





<!--
2nd analysis - use the same input information
-->

Nonparametric Analysis {data-orientation=columns}
=====================================     
   
   
Column {data-width=450  .tabset .tabset-pills}
-------------------------------------
    

### Parametric and Nonparametric Regression


```{r}
renderPlot({
  regdata = workDat()
  if (input$species == "all"){
    Y0 = iris1[[input$Y]]
    X0 = iris1[[input$X]]
    ## local regression
    locavg = supsmu(X0, Y0)
    ## Loess-CV
    locreg = loess.as(X0, Y0, criterion = "gcv")
    ## Kernel reg
    kern = loess.smooth(X0, y = Y0, span = 0.5)
    ###
    m0 = lm(Y0~X0)
    plot(X0, Y0,
      main = "",
      type = "p",
      pch = 19,
      col = "blue",
      xlab = input$X,
      ylab = input$Y
      )
    abline(m0, lwd = 2, col = "#1B9E77")
    lines(locavg, lwd = 2, col = "#D95F02")
    #lines(locreg, lwd = 2, lty = 2, col = "#7570B3")
    lines(kern, lwd = 2, lty = 3, col = "#E7298A")
  } else {
    Y0 = workDat()[[input$Y]]
    X0 = workDat()[[input$X]]
    ## local regression
    locavg = supsmu(X0, Y0)
    ## Loess-CV
    locreg = loess.as(X0, Y0, criterion = "gcv")
    ## Kernel reg
    kern = loess.smooth(X0, y = Y0, span = 0.5)
    ###
    m1 = lm(Y0~X0)
    plot(X0, Y0,
      main = "",
      type = "p",
      pch = 19,
      col = "blue",
      xlab = input$X,
      ylab = input$Y
      )
    ##  
    abline(m1, lwd = 2, col = "#1B9E77")
    lines(locavg, lwd = 2, col = "#D95F02")
    #lines(locreg, lwd = 2, lty = 2, col = "#7570B3")
    lines(kern, lwd = 2, lty = 3, col = "#E7298A")
    ##
  }
})
```




Column {data-height=350}
-------------------------------------
   
### Bootstrap Methods-Sampling Cases


```{r}
renderPlot({
  regdata = workDat()
  if (input$species == "all"){
    Y0 = iris1[[input$Y]]
    X0 = iris1[[input$X]]
    ###
    m0 = lm(Y0~X0)
    ##
    alpha0 = NULL
    beta0 = NULL
    for(i in 1:100){
      n = length(Y0)
      ##
      bt.ID= sample(1:n, n, replace=TRUE)
      bt.y = Y0[bt.ID]
      bt.x = X0[bt.ID]
      bt.m0 = lm(bt.y ~ bt.x)
      bt.coef= coef(bt.m0)
      alpha0[i] = bt.coef[1]
      beta0[i] = bt.coef[2]
    }
    ##
    par(mfrow=c(1,2))
    hist(alpha0,
      main = "Bootstrap Distribution of intercept",
      xlab = "Bootstrap intercept",
      cex.main = 0.8,
      col.main = "brown"
      )
    hist(beta0,
      main = "Bootstrap Distribution of Slope",
      xlab = "Bootstrap Slope",
      cex.main = 0.8,
      col.main = "purple"
      )
  } else {
    Y0 = workDat()[[input$Y]]
    X0 = workDat()[[input$X]]
    ###
    alpha1 = NULL
    beta1 = NULL
    for(i in 1:100){
      n = length(Y0)
      ##
      bt.ID= sample(1:n, n, replace=TRUE)
      bt.y = Y0[bt.ID]
      bt.x = X0[bt.ID]
      bt.m0 = lm(bt.y ~ bt.x)
      bt.coef= coef(bt.m0)
      alpha1[i] = bt.coef[1]
      beta1[i] = bt.coef[2]
    }
    ##
    par(mfrow=c(1,2))
    hist(alpha1,
      main = "Bootstrap Distribution of intercept",
      xlab = "Bootstrap intercept",
      cex.main = 0.8,
      col.main = "brown"
      )   
    hist(beta1,
      main = "Bootstrap Distribution of Slope",
      xlab = "Bootstrap Slope",
      cex.main = 0.8,
      col.main = "purple"
      )     
  }
})
```
    
### Bootstrap Method - Sampling Residuals


```{r}
renderPlot({
  regdata = workDat()
  if (input$species == "all"){
    Y0 = iris1[[input$Y]]
    X0 = iris1[[input$X]]
    ###
    m0 = lm(Y0~X0)
    coef0 = coef(m0)
    a0 = coef0[1]
    b0 = coef0[2]
    r0 = resid(m0)
    ##
    alpha0 = NULL
    beta0 = NULL
    for(i in 1:100){
      n = length(Y0)
      ##
      bt.ID= sample(1:n, n, replace=TRUE)
      ##
      bt.y = a0 + b0*X0 + r0[bt.ID]
      bt.x = X0
      bt.m0 = lm(bt.y ~ bt.x)
      bt.coef= coef(bt.m0)
      alpha0[i] = bt.coef[1]
      beta0[i] = bt.coef[2]
    }
    ##
    par(mfrow=c(1,2))
    hist(alpha0,
      main = "Bootstrap Distribution of intercept",
      xlab = "Bootstrap intercept",
      cex.main = 0.8,
      col.main = "brown"
      )
    hist(beta0,
      main = "Bootstrap Distribution of Slope",
      xlab = "Bootstrap Slope",
      cex.main = 0.8,
      col.main = "purple"
      )
  } else {
    Y0 = workDat()[[input$Y]]
    X0 = workDat()[[input$X]]
    ##
    m0 = lm(Y0~X0)
    coef0 = coef(m0)
    a0 = coef0[1]
    b0 = coef0[2]
    r0 = resid(m0)
    ##
    alpha1 = NULL
    beta1 = NULL
    for(i in 1:100){
      n = length(Y0)
      ##
      bt.ID= sample(1:n, n, replace=TRUE)
      ##
      bt.y = a0 + b0*X0 + r0[bt.ID]
      bt.x = X0
      bt.m0 = lm(bt.y ~ bt.x)
      bt.coef= coef(bt.m0)
      alpha1[i] = bt.coef[1]
      beta1[i] = bt.coef[2]
    }
    ##
    par(mfrow=c(1,2))
    hist(alpha1,
      main = "Bootstrap Distribution of intercept",
      xlab = "Bootstrap intercept",
      cex.main = 0.8,
      col.main = "brown"
      )   
    hist(beta1,
      main = "Bootstrap Distribution of Slope",
      xlab = "Bootstrap Slope",
      cex.main = 0.8,
      col.main = "blue"
      )     
  }
})
```


Other Analyses {data-orientation=rows}
===================================== 


Row {data-height=600}
-----------------------------------
### Other Analyses - Part I

```{r}
```

Row {data-height=200}
-------------------------------------
   
    
### Other Analyses - Part II

```{r}
```
